\section{Cheney's algorithm}
\label{sec:cheneycode}

\begin{verbatim}
// LispObject is just a pointer type
typedef uintptr_t LispObject;

// LispObject is a pointer type
uintptr_t fringe1, limit1; // heap1, where all allocations happen
uintptr_t fringe2, limit2; // heap2 used for copying GC

LispObject allocate(size_t size) {
  if (fringe1 + size > limit1) {
    collect();
  }

  if (fringe1 + size > limit1) {
     // We are out of memory. Try to increase memory
     // ...
  }

  uintptr_t result = fringe1;
  fringe1 += size;
  return result;
}

// Two helper functions are needed
LispObject copy(LispObject obj) {
  size_t len = size(obj);

  LispObject new_obj = static_cast<LispObject>(fringe2);
  fringe2 += len;
  return new_obj;
}

uintptr_t copycontent(LispObject obj) {
  for (auto ref&: forward_references(obj)) {
    ref = copy(ref);
  }

  return static_cast<uintptr_t>(obj) + size(obj);
}

void collect() {
  // First we copy over the root set, which includes symbols.
  for (LispObject& symbol: symbols_table) {
    symbol = copy(symbol);
  }

  uintptr_t s = heap2;
  while (fringe2 < fringe2) {
    s = copycontent(static_cast<LispObject>(s));
  }

  swap(fringe1, fringe2);
  swap(limit1, limit2);
}
\end{verbatim}

\section{\texttt{Gc\_guard} and \texttt{Gc\_lock}}
\label{sec:gclock-code}

\begin{verbatim}
namespace {
std::atomic_int num_threads(0);
std::atomic_int paused_threads(0);
std::condition_variable gc_waitall;
std::condition_variable gc_cv;
std::atomic_bool gc_on(false);

std::mutex gc_guard_mutex;
std::mutex gc_lock_mutex;
}

class Gc_guard {
public:
    Gc_guard() {
        int stack_var = 0;
        td.C_stackhead = (LispObject *)((intptr_t)&stack_var & -sizeof(LispObject));

        paused_threads += 1;
        gc_waitall.notify_one();
    }

    ~Gc_guard() {
        std::unique_lock<std::mutex> lock(gc_guard_mutex);
        gc_cv.wait(lock, []() { return !gc_on; });
        paused_threads -= 1;

        td.C_stackhead = nullptr;
    }
};

class Gc_lock {
private:
    std::unique_lock<std::mutex> lock;

public:
    Gc_lock() : lock(gc_lock_mutex) {
        int stack_var = 0;
        td.C_stackhead = (LispObject *)((intptr_t)&stack_var & -sizeof(LispObject));

        gc_on = true;

        paused_threads += 1;
        gc_waitall.wait(lock, []() {
            return paused_threads == num_threads; });
    }

    ~Gc_lock() {
        paused_threads -= 1;
        gc_on = false;
        td.C_stackhead = nullptr;
        gc_cv.notify_all();
    }
};
\end{verbatim}

\section{Shallow binding}
\label{sec:shallowbind-code}

\begin{verbatim}
class Shallow_bind {
    private:
        int loc;
        LispObject save;
    public:
        Shallow_bind(LispObject x, LispObject tval) {
            if (is_global(x)) {
                error1("shallow bind global", qpname(x));
            }

            loc = qfixnum(qvalue(x));
            LispObject& sv = td.local_symbol(loc);
            save = sv;
            sv = tval;
        }

        Shallow_bind(Shallow_bind&&) noexcept = default;

        ~Shallow_bind() {
            td.local_symbol(loc) = save;
        }
    };
\end{verbatim}

\section{Lock free symbol lookup}
\label{sec:lockfree-code}

\begin{verbatim}
/**
* [search_bucket] searches a particular bucket in the symbol table
* It can search the whole bucket, or down to a location.
* If specifying [stop] make sure it is in the bucket, otherwise it will loop.
* Returns -1 if not found.
* */
LispObject search_bucket(LispObject bucket, const char *name, size_t len, LispObject stop=tagFIXNUM) {
    for (LispObject w = bucket; w != stop; w = qcdr(w)) {
        LispObject a = qcar(w);    // Will be a symbol.
        LispObject n = qpname(a);      // Will be a string.
        size_t l = veclength(qheader(n)); // Length of the name.

        if (l == len && strncmp(name, qstring(n), len) == 0) {
            return a;                  // Existing symbol found.
        }
    }

    return -1;
}

LispObject lookup(const char *name, size_t len, int flag)
{
    size_t loc = 1;
    for (size_t i = 0; i < len; i += 1) loc = 13 * loc + name[i];
    loc = loc % OBHASH_SIZE;

    LispObject bucket = obhash[loc].load(std::memory_order_acquire);
    LispObject s = search_bucket(bucket, name, len);

    if (s != -1) return s; // found the symbol

    if ((flag & 1) == 0) return undefined;
    LispObject pn = makestring(name, len);
    LispObject sym = allocatesymbol(pn);

    LispObject new_bucket = cons(sym, bucket);

    while (!obhash[loc].compare_exchange_strong(bucket, new_bucket, std::memory_order_acq_rel)) {
        LispObject old_bucket = bucket;
        bucket = obhash[loc].load(std::memory_order_acquire);

        // Reaching here means bucket is constructed from old_bucket
        s = search_bucket(bucket, name, old_bucket);

        if (s != -1) return s; // another thread has created the symbol in the meantime

        new_bucket = cons(sym, bucket);
    }

    // successfully inserted the symbol in the hash, can return it.
    return sym;
}
\end{verbatim}


\section{Thread pool}
\label{sec:threadpool-code}

\begin{verbatim}
lisp;

symbolic procedure queue;
    {nil, nil};

symbolic procedure q_push(q, x);
    begin scalar back, newback;
        back := second q;
        newback := {x};

        if null back then <<
            rplaca(q, newback);
            rplaca(cdr q, newback); >>
        else <<
            rplacd(back, newback);
            rplaca(cdr q, newback); >>;
        return q;
    end;

symbolic procedure q_pop(q);
    begin scalar front, next;
        front := first q;
        if null front then
            return {}
        else <<
            next := cdr front;
            if null next then rplaca(cdr q, {});
            rplaca(q, next);
            return (first front); >>;
    end;

symbolic procedure q_empty(q);
    null (first q);

symbolic procedure atomic(val);
    {mutex(), val};

symbolic procedure atomic_set(a, val);
begin
    scalar m;
    m := first a;

    mutexlock m;
    rplaca(cdr a, val);
    mutexunlock m;
end;

symbolic procedure atomic_get(a);
begin
    scalar m, res;
    m := first a;

    mutexlock m;
    res := cadr a;
    mutexunlock m;
    return res;
end;

symbolic procedure safeq();
    {queue(), mutex(), condvar()};

symbolic procedure safeq_push(sq, x);
    begin scalar q, m, cv;
        q := first sq;
        m := second sq;
        cv := third sq;

        mutexlock m;
        q_push(q, x);
        condvar_notify_one cv;
        mutexunlock m;
        return sq;
    end;

symbolic procedure safeq_pop(sq);
    begin scalar q, m, cv, res;
        q := first sq;
        m := second sq;
        cv := third sq;
        res := nil;

        mutexlock m;
        while q_empty q do condvar_wait(cv, m);
        res := q_pop q;
        mutexunlock m;
        return res;
    end;

% non-blocking call
symbolic procedure safeq_trypop(sq);
    begin scalar q, m, cv, res;
        q := first sq;
        m := second sq;
        cv := third sq;
        res := nil;

        mutexlock m;

        if q_empty q then
            res := nil
        else
            res := {q_pop q};

        mutexunlock m;
        return res;
    end;

symbolic procedure safeq_empty(sq);
    begin scalar r, m;
        m := second sq;
        mutexlock m;
        r := q_empty (first sq);
        mutexunlock m;
        return r;
    end;

symbolic procedure future();
    {mutex (), nil};

% blocking call to wait for future result
symbolic procedure future_get(fut);
begin
    scalar m, state, cv, res;
    m := first fut;
    mutexlock m;

    state := second fut;

    if state = 'done then <<
        res := third fut;
        mutexunlock m;
        return res >>;

    if state = 'waiting then
        cv := third fut
    else <<
        cv := condvar ();
        rplacd(fut, {'waiting, cv}) >>;


    condvar_wait(cv, m);
    % ASSERT: promise is fulfilled here

    res := third fut;
    mutexunlock m;

    return res;
end;

% non-blocking call for future result
% can wait on cv until timeout
symbolic procedure future_tryget(fut, timeout);
begin
    scalar m, state, cv, res;
    m := first fut;
    mutexlock m;

    state := second fut;

    if state = 'done then
        res := {third fut}
    else if timeout = 0 then
        res := nil
    else <<
        if state = 'waiting then
            cv := third fut
        else <<
            cv := condvar ();
            rplacd(fut, {'waiting, cv}) >>;

        if condvar_wait_for(cv, m, timeout) then
            res := {third fut}
        else
            res := nil >>;

    mutexunlock m;

    return res;
end;

symbolic procedure future_set(fut, value);
begin
    scalar m, state;
    m := first fut;

    mutexlock m;
    state := second fut;

    if state = 'done then
        error("future already set");

    if state = 'waiting then
        condvar_notify_all third fut;

    rplacd(fut, {'done, value});
    mutexunlock m;
end;

symbolic procedure tp_runjob(tp);
begin
    scalar tp_q, job, resfut, f, args, res;
    tp_q := first tp;
    job := safeq_trypop tp_q;
    if null job then thread_yield ()
    else <<
        job := first job;
        resfut := first job;
        f := second job;
        args := third job;
        res := errorset({'apply, mkquote f, mkquote args}, t);
        future_set(resfut, res);
    >>
end;

symbolic procedure thread_pool_job(tp_q, status);
begin
    scalar job, resfut, f, args, res, stat;
    job := safeq_trypop tp_q;
    repeat <<
        if job then <<
            job := first job;
            resfut := first job;
            f := second job;
            args := third job;
            res := errorset({'apply, mkquote f, mkquote args}, t);
            future_set(resfut, res);
        >> else <<
            thread_yield ();
        >>;
        job := safeq_trypop tp_q;
        stat := atomic_get status;
    >> until (stat = 'kill) or (stat = 'stop and null job);

    return nil
end;

symbolic procedure thread_pool(numthreads);
    begin scalar tp_q, status, threads;
        tp_q := safeq();
        status := atomic 'run;
        threads := {};
        % print "starting workers";
        for i := 1:numthreads do threads := thread2('thread_pool_job, {tp_q, status}) . threads;
        return {tp_q, status, threads};
    end;

symbolic procedure tp_addjob(tp, f, args);
begin
    scalar tp_q, status, resfut;
    tp_q := first tp;
    status := atomic_get (second tp);

    if not (status = 'run) then
        return nil
    else <<
        resfut := future ();
        % print "pushing job";
        safeq_push(tp_q, {resfut, f, args});
        return resfut;
    >>;
end;

symbolic procedure tp_stop(tp);
begin
    scalar threads;
    atomic_set(second tp, 'stop);
    threads := third tp;
    for each td in threads do <<
        jointhread td;
    >>;
    return nil;
end;

symbolic procedure tp_kill(tp);
begin
    scalar threads;
    atomic_set(second tp, 'kill);
    threads := third tp;
    for each td in threads do <<
        jointhread td;
    >>;
end;

end;
\end{verbatim}