The motivation for this project is to explore the implementation of multi-threading
capabilities within a working compiler and assess the benefits and trade-offs it brings
to a real-world application with a large, actively-developed body of code.

\section{Reduce}

Reduce \cite{reduce} is a portable general-purpose computer algebra system (CAS). It enables symbolic
manipulation of mathematical expressions and provides a wide range of algorithms
to solve problems spanning many fields, with arbitrary precision numerical approximation.
It has a friendly user interface and can display maths and generate graphics.

Reduce is one of a few open-source general-purpose CAS programs, alongside Maxima and Axiom.
The three projects are all built on top of different Lisp kernels. At the time of this writing,
none of these projects have any multi-threaded capabilities. My aim is to remove this limitation
for Reduce. The project is using its own Lisp dialect which is similar to Common Lisp, but has its
own design and set of capabilities.

\section{VSL}

There are multiple implementations of the Lisp backend Reduce uses: PSL, CSL and VSL.
Visual Standard Lisp (VSL) is an interpreted language written
in \texttt{C}. It is fully capable of building the entirety of Reduce, supports all the major
platforms and architectures, and is well optimised for speed, minimising the performance tradeoff
of being interpreted. It exists to provide a test-bed for ideas that may later move to the much larger,
compiled CSL version.

\section{Benefits of multithreading}
The idea of using parallel computing to speed up computer algebra computing has come
up in research papers for many years \cite{GabrielQML,multilisp,multilisp-implementation},
but much of the activity
pre-dates the now ubiquitous multi-core CPUs used in modern computers and the amount of memory
they now provide. Moreover, advancements in single-core CPU performance has slowed down
significantly, as clock speeds have stagnated and even gone down in recent years. The biggest
area of improvement in these new CPUs is their core count and number of hardware threads.
Binding the performance of Reduce to single-threaded performance is likely to lead to
a limitation in speed gains from new hardware. This project involves proving the infrastructure
Reduce will need to take full advantage of today's hardware.

\section{Code examples}

To help explain the concepts I introduce, I will use code fragments to show the algorithms.
These fragments will be a simplification of the original code, in order to remove the need
for context within the rest of the codebase. To that end, the names and function interfaces
are different from the real implementation. More complete versions of the code fragments
I showcase can be found in the Appendix \ref{ch:appendix-code}.

For examples relating to the implementation of the interpreter, I will be using C++.
For work related to my evaluation, I will be showcasing the ParVSL language, which is a type
of Lisp. Reduce implements an additional language running on top of Lisp, called RLisp.
I have tried my best to keep RLisp examples short and as readable
as possible. Where I think the syntax of the language get in the way of readability, I
switch to pseudo-code to aid my explanations.

% TODO: Write Achievements (see Arthur's comments)
% \section{Achievements}
% \label{sec:achievements}

% My project involved modifications to several thousand lines of C/C++ code, upgrading it to
% make better idiomatic use of C++ as well as adding concurrency support. It has also used raw
% Lisp code in bracket notation, along with the